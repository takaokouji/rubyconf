title: "RubyConf 2011 MacRuby on Rails 発表原稿"
author: "高尾宏治"
date: "2011/09/28"

= Fix slides at:

Torさんへ、このTODOのところに私へのスライドの修正指示を書いてください。
わかりました、そのうち書きます。--Tor

TODO: これから修正します。
すみません、スライドの修正については今後スライドに該当する現行の辺に書かせてください。
Done: 以下は修正が完了しています。
21 (and the following slides):
 Employee Oneself (in blue frame) > Employee
 First: Employee Oneself > First: Employee
 Next: Employee Family > Next: Employee's Family
 Finally: Company
31
 Library > System libraries
40
 Not sure but it looks like "(I)Click". Maybe you need to change it to "(1)Click" ?
 ie. "i" to "1" (one)
 -> フォントを修正して数字の1に見えるようにしました。
 
= はじめに

これはRubyConf2011で私が発表する「MacRuby on Rails」の原稿です。
当日は基本的にこの資料に書いたとおりのことを話します。

= MacRuby on Rails

(司会者がいない場合)
Now, I am about to start my presentation.

(司会者がいる場合)
Thank you for your kind introduction.

---

I would like welcome all of you.
It is a great honor for me to be here.

= Kouji Takao

Please let me introduce myself first. And let me introduce my company.

My name is Kouji Takao.
Both Kouji and Takao are commonly used as first names in Japan.
In my case, Kouji is my first name. And Takao is my last name.
Please call me Kouji.

<<click>>

I am a Research Engineer at Network Applied Communication Laboratory Ltd.
In Japan, my company is famous in connection with the Ruby programming language.

As for me, my work includes anything related to system integration.
For example, system design, programming, planning and meeting with the customers.

And I work as the leader of small team.

<<click>>

I develop open source software during my spare time.

I'm a MacRuby and cRuby committer.
In MacRuby, I am in charge of some of the Core parts.
In cRuby, I am in charge of the Readline module.

<<click>>

You can contact me on e-mail, twitter or facebook.

<<click>>

= My Company

<<click>>

As I said previously, my company's name is Network Applied Communication
Laboratory Ltd. 

<<click>>

My company is also known as NaCl.
As you probably know, NaCl means salt(ソォルト).
Salt(ソォルト) is necessary for all creatures to live.
This is why we named the company NaCl.

<click>>

You can check out NaCl's homepage at www.netlab.jp.

<<click>>

NaCl is located in Shimane Prefecture in Japan.

<<click>>

The company was founded in 2001.
So, 2011 is the 10th anniversary.
By the way, it's also my own 10th anniversary as an employee!
Yeah!!

<<click>>

57 people work at my company.

Wow, that's a lot of Rubyists!?
Just joking :)
Actually, about half of my co-workers work using Ruby.

However, 6 people are cRuby committers.

<<click>>

The company works with System Integration, Training and so on.

<<click>>

= The NaCl Way (part 1)

Please let me introduce The NaCl Way as I see it.

<<click>>

This is our president. His name is Hiroshi Inoue.

<<click>>

= The NaCl Way (part 2)

In a speech at my co-worker's wedding party, he said to my co-worker.

<<click>>

First, I want You to be happy.

<<click>>

Next, I want you to make Your Family happy.

<<click>>

Finally, if you have more happiness left, then please share it with Our Company :)

<<click>>

= The NaCl Way (part 3)

So I think the priorities of my company is as follows...

<<click>>

First, The Employee's well-being

<<click>>

Next, the well-being of the Employee's Family

<<click>>

And finally: The company itself

<<click>>

This is why I love my company!!

= MacRuby on Rails

Now, Let's continue on to the main topic of today.

<<click>>

MacRuby on Rails

I will explain how I modified MacRuby to make it a suitable foundation
for running Rails. I would also like to explain some of the technical
intricacies that I discovered along the way.

<<click>>

= MacRuby

First, I would like to first briefly explain about MacRuby.

<<click>>

= MacRuby (part 2)

MacRuby is a unique blend of Ruby 1.9 and Objective-C.

<<click>>

The goal of the MacRuby project is to be 100% compatible syntactically
and behaviorally with Ruby 1.9.

<<click>>

= Ruby 1.9

This is Ruby 1.9.

これは Ruby 1.9 の場合のシステムブロック図です。
上がユーザよりで、下がハードウェアよりを表しています。
This system diagram shows the main building blocks of Ruby 1.9.
The top side shows the blocks facing the user,
and the bottom side shows the blocks facing the hardware.

上からユーザが作成したアプリケーション。例えば... Railsのようなミドルウェ
アも含めます。
At the top we have the applications made by the Ruby user.
For instance an application such as Rabbit or middleware such as Ruby on Rails.

その下が Ruby バージョン 1.9 です。
ここでは Ruby の主要な部品を紹介します。
Below that we have Ruby 1.9.
These are Ruby's main building blocks.

以前は yarv と呼ばれていた Ruby VM 
We have Ruby VM(ブィーエム), 
Ruby's Virtual Machine, 
which was previously called YARV(ヤーブィ).

We have the built-in garbage collection, which uses mark and sweep.

StringやArrayなどを含むBuilt-in Library
Then we have the Built-in Libraries, 
which includes the String class and the Array class and so on.

ReadlineやOpenSSLなどのStandard Library
And then we have the Standard Library, 
which includes Readline, OpenSSL and so on.

その下が Library です。
Below Ruby, we have the system libraries.

そして、OS です。Ruby 1.9 はLinux、Windows、Mac OS Xなど、さまざまなプ
ラットフォームで動作します。
And below the libraries, we have the Operating System.
Ruby 1.9 operates on a number of different platforms, 
among others Linux, Windows, Mac OS X and so on.

Ruby 1.9 はこのような構成になっています。
So, this is the structure of Ruby 1.9.

<<click>>

= MacRuby (part 3)

次に MacRuby の場合のシステムブロック図を Ruby 1.9 と比較しながら上から
順に見ていきましょう。
So let's try to compare this with the system diagram as it looks for MacRuby.
We'll look at each element in turn.

Application はそのままです。
The application stays as it is.

当然、Ruby 1.9 は MacRuby に変わります。
Naturally, Ruby 1.9 becomes MacRuby.

<<click>>

Ruby VMは、LLVM で置き換えています。
Ruby VM(ヴィーエム) is replaced by LLVM(エルエルヴィーエム).

<<click>>

Built-in GCは、Mac OS Xが提供しているGCに置き換えられています。
それはAutoZoneという名前です。
AutoZoneは、Generational でかつ Threaded という特徴があります。

The built-in Garbage Collection is replaced by the mechanism provided by Mac OS X.
This Mac OS X feature is called AutoZone.
AutoZone is a Generational and Threaded Garbage Collection mechanism.

<<click>>

Built-in Libraryの一部は、Mac OS Xが提供している Foundation と呼ばれる
機能を使って置き換えられています。
Object、Array、String、Hashなどが置き換えられています。
その結果、それらのクラスに Ruby が提供する機能だけでなく、Foundation が
提供する機能が追加されています。

Part of the Built-in Library is replaced by a feature
called Foundation which is provided by Mac OS X.
Object, Array, String, Hash and others are replaced this way.
The result is that these classes get not only the functionality
provided by Ruby,
but also the functionality provided by Foundation.

<<click>>

例えば、Stringにはtransformというメソッドが追加されています。そのメソッ
ドは、"kouji"に適用すると日本語のキャラクタに変換できます。
For instance, 
a Foundation method called "transform" is added to the Ruby String class.
This method can convert the alphabet version of my name "kouji"
into the corresponding japanese hiragana characters.

<<click>>

Standard Libraryはほとんどそのままです。
The Standard Libraries are more or less similar to Ruby 1.9.

その下のLibraryもそのままです。
The system libraries are also unchanged.

そして、OSはMac OS Xです。実はMacRubyはMac OS Xでしか動かないのです :)
And the OS is of course Mac OS X.
Actually, MacRuby only runs on Mac OS X.

<<click>>

= MacRuby (part 4)

あらためて全体を見てみるとこんな感じです。
So, if we look at the whole... well, then it looks like this.

<<click>>

= Cocoa

Mac OS X には、 Cocoa という Objective-C で書かれたライブラリがあります
On Mac OS X we have a library called Cocoa which is written in Objective-C.。

Cocoa には、Mac OS X の機能のほぼ全て（例えば、GUI、画像・動画などのマ
ルチメディア、テキストの読み上げなど）が含まれています。
The Cocoa library includes more or less all the features of Mac OS X, for instance a GUI toolkit, multimedia processing, text-to-speech and so on.

Mac OS Xのアプリケーションの多くはCocoaを使って開発されています。
The majority of Mac OS X applications are developed using Cocoa.
<<click>>

= MacRuby x Cocoa

MacRuby は Cocoa を簡単に利用できます。
実際、Cocoa を使うために MacRuby が存在しているといってもいいでしょう。
It is easy to use Cocoa in MacRuby.
Actually we could say, that MacRuby exists in order to allow us to use Cocoa.

<<click>>

= MacRuby x Cocoa

それでは、MacRubyからCocoaの使用例を見てみましょう。
Well then, let's look at an example of how we can use Cocoa from MacRuby.

<<click>>

これは、サウンドを再生するサンプルプログラムです。
This is a sample program that plays a sound.

<<click>>

MacRubyにはframeworkというメソッドが定義されています。
MacRuby defines a method called "framework".
このメソッドは、Cocoa などの system libraries をロードするためのメソッドです。
The purpose of the "framework" method is to load system libraries such as Cocoa.

<<click>>

実際に Cocoa の機能を使っているのはこの部分です。
This is the part where we are actually using Cocoa's functionality.
ファイル名を指定して、サウンドファイルのインスタンスを生成します。
We specify a filename and we generate an instance of a sound file.
そして、playメソッドを呼び出してサウンドを再生しています。
And then we call the "play" method to play back the sound.

<<click>>

= HelloMacRuby
  
次は、 GUI アプリケーションのサンプルプログラムです。
Next we have a sample program showing a GUI application.

名前は HelloMacRuby とします。
Let's call it HelloMacRuby.

<<click>>

「Push me!」ボタンをクリックします。
So, we click the "Push me!" button.

<<click>>

TODO: ここを書いているところ

すると、テキストフィールドに"Hello,MacRuby!"と表示します。
And this displays "Hello, MacRuby" in the text field.

このような簡単なプログラムです。
So, this is just a simple example program.

<<click>>

= HelloMacRuby (part 2)

XcodeHelloMacRuby の作成
Creating XcodeHelloMacRuby

<<click>>

= MacRuby on Rails

TODO:

<<click>>

= Current Status

現在では...
Let's see what we can currently do with MacRuby on Rails

<<click>>

Railsプロジェクトの新規作成
Creating a new Rails project.

<<click>>

scaffoldの実行
Generating a scaffold.

<<click>>

serverの起動
Starting up the server.

<<click>>

そして、Welcome Pageの表示
And ... showing the welcome page.

このように、なにも修正していないRailsをMacRubyで動作させることができます。
So, it is currently possible to run a Rails application on MacRuby without modifying Rails.

However, it wasn't always like this. Let's travel back in time!

<<click>>

= 7 months ago...

7 months ago...

May 2011 in Japan.

<<click>>

I thought, "Does Rails work on MacRuby?".

<<click>>

I tried to install Rails on MacRuby. And it worked.

<<click>>

= Perhaps...

So, I thought, "OK, it installed, but surely the Rails
generators won't work..."

<<click>>

I tried to create a Rails project. And it actually worked!?

<<click>>

= Are you kidding me?

Not believing my own eyes, I tried to generate a scaffold...

<<click>>

Then it failed. After all Rails didn't work on MacRuby.

<<click>>

= My approach

So what did I do? My approach was to follow the five-step process
shown here iteratively.

First, run Rails.

The next step is to see where it fails.
For instance, segmentation faults, abort
programs and so on.

The third step is when I research the cause of the failure.

The fourth step is to code a patch that fixes the problem.

And finally, I run RubySpec to verify my patch, 
and repeat from the top if necessary.

<<click>>

In order to do this, I needed to know about cRuby, Objective-C, C++
and LLVM.

When you just work with cRuby then you only need to know about cRuby.

But, when you want to code patches for MacRuby then you also need to
know about Objective-C, C++ and LLVM.

So, I think that to code patches for MacRuby is more difficult than
to do so for cRuby.

<<click>>

= #860 catch/throw

私は私がMacRubyを修正した箇所のうちのいくつかを紹介したいと思います。
Now, I would like to discuss a couple the issues that I fixed in MacRuby.

最初の修正です。
Let's have a look at the first case, which is ...

Trac Issue No.860,
an issue with catch and throw and exception handling in MacRuby.

<<click>>

This error can be reproduced by this code.

<<click>>

If you run this code, then the following error will occur.

Let me explain the reason.

<<click>>

First, 'throw' pops an Exception from the stack.

<<click>>

Then, when the rescue block ends,
then MacRuby tries to pop another Exception from the stack.
This causes an error since the stack is empty!

<<click>>

= #860 catch/throw (part 2)

TODO:

The MacRuby implementation at that time assumed the following way of
writing exception handling.
SLIDE_TODO: 「MacRuby assumed a specific code structure for exception handling」をスライド７４に追加するといいと思います。

The issue does not occur, as long as you don't break this assumption.

With this exception handling structure, if we reach end, then it means that throw was NOT executed. On the other hand if throw is executed, then we break out of the begin rescue end block before we reach end.

In other words, this structure ensures that you never pop more than one exception from the stack.
SLIDE_TODO: "If reached 'end', pop Exception. However can't reach here in this case." > "If we reach 'end', it means that the throw statement was not executed."
SLIDE_TODO: "So we should pop Exception when we perform 'throw'" > "And if 'throw' is executed, then we won't reach 'end'.
SLIDE_TODO: Add "This means that we never pop more than one exception from the stack".
TODO:この辺りの訂正案は流れと内容を大きく変えるので、要確認だと思います。そして、スライドの切り替えとの調節が必要かみしれないですね。--Tor

しかし、Railsではこの前提が崩れてしまった。
However, this assumption does not hold true in Rails.

そのため動かなかった。
So, this caused an error when running Rails on MacRuby.

Before being fixed(60723bf~), 'throw' always popped the current Exception.

<<click>>

実装はこのようになっています。
The MacRuby implementation at that time was like this.
TODO:この辺はスライド７８だと思います（vm.cppを引用したところ）

<<click>>

= #860 catch/throw (part 3)

TODO:

I changed the implementation so that MacRuby only pop Exceptions if it needs to.(60723bf)

<<click>>

= #860 catch/throw (part 4)

TODO:

ここで説明する。

<<click>>

= #1192 Constant lookup

それでは次の修正を説明します。
Next, let's look at another example of how I fixed MacRuby, the 

Trac Issue number 1192 (one one nine two), which is related to Constant Lookup in MacRuby

これは次の問題(Issue)です。
The issue was that MacRuby failed to ...

module_evalやclass_evalをつかったような、いくつかのケースで定数の探索に
失敗してしまう。
 ... correctly look up constants in a number of situations when you used module_eval and class_eval.
 TODO:要確認です。そして２つの文書を一つにまとめてもいいとおもいます。--Tor

Almost can't lookup nested constants.

<<click>>

This error can be reproduced by this code.

<<click>>

If you run this code, then the following error will occur.

<<click>>

Object.class_eval { B } の行を見てください。

定数Bを探すときcRubyでは、最初にこの枠の範囲を対象にします。
そして、定数Bを見つけます。

<<click>>

しかし、MacRubyではclass_evalのレシーバであるObjectからしか探索しませんでした。
当然、Objectには定数Bは定義されていません。その結果、定数Bの探索に失敗します。

can't lookup Constant B assumes lookup it from Object

<<click>>

= #1192 Constant lookup (part 2)

この問題を理解するには、Rubyにおける定数の探索のやり方を詳しく知る必要があります。そしてまた、それはRubyの言語仕様の中でもとても難しい問題の一つです。

なお、定数探索の詳細を知っておかなくても多くの場合に困りません。

<<click>>

まずはこのコードを見てください。

上から順番に説明します。

1行目で、module Aを定義します。
2行目で、module Bを定義します。
3行目で、module Bに定数CONSTを定義します。
4行目で、トップレベルのmodule A、つまり1行目で定義したmodule Aを再定義します。
5行目で、定数CONSTを標準出力に出力します。

<<click>>

このとき、cRubyではこの枠の範囲から定数CONSTを探索します。
そして、module Bに定義された定数CONSTを見つけます。

<<click>>

この枠の範囲を Lexical Scope といいます。

また、本プレゼンテーションでは Lexical Scope から定数を探索することを
Lexical Constant Lookupと呼びます。

<<click>>

当時のMacRubyには、Lexical Constant Lookup が実装されていませんでした。

Before fixed (6b101bd~), didn't implement the Lexical Constant Lookup

<<click>>

このコードの場合だと、5行目では、module Aからしか定数CONSTを探索しませ
んでした。

<<click>>

その結果、定数CONSTを見つけることができませんでした。

<<click>>

= Constant Lookup is complex

次はclass_evalを使った例です。

class_evalを使うと、定数探索はもっと複雑になります。

class_evalに文字列を渡すか、それともブロックを渡すかで結果が異なります。

左が文字列を渡しています。

右がブロックを渡しています。

それ以外の違いはありません。

<<click>>

= class_eval(&Block)

Blockを渡す場合について、上から順に説明します。

First, about performing class_eval with Block. 
Let me explain this code sequentially from the top.

1行目で、module Aを定義します。
2行目で、定数CONSTを定義します。
3行目で、メソッドfを定義します。
4行目で、class_evalをブロックを渡して呼び出します。
5行目で、定数CONSTを標準出力に出力します。
6行目で、class_evalに渡すブロックの終端を指定します。
実際には、4〜6行目はメソッドfを呼び出したときに実行されます。

少し飛ばします。
10行目で、class Kを定義します。
11行目で、class Kに定数CONSTを定義します。
12行目で、extend Aを実行します。
13行目で、module Aのメソッドfを呼び出します。

その結果、4〜6行目が実行されます。

このときの定数CONSTを最初に探索する範囲がわかりますか？

<<click>>

これは簡単ですね。

先ほどの説明と同様の理由から、この枠の範囲から最初に定数CONSTを探索します。

<<click>>

Therefore, 'p method' outputs the string "A's CONST".

<<click>>

= class_eval(String)

次に、文字列を渡す場合についてです。

Next, about performing class_eval with String.

先ほどのものとの違いは4〜6行目だけです。

4行目で、class_evalを文字列を渡して呼び出します。
5行目で、定数CONSTを標準出力に出力します。
6行目で、ヒアドキュメントの終端を指定します。
実際には、4〜6行目はメソッドfを呼び出したときに実行されます。

そして、先ほどと同様に、13行目で、module Aのメソッドfを呼び出します。

このときの定数CONSTを最初に探索する範囲がわかりますか？

<<click>>

実はこの枠の範囲です。

これは、メソッドfの実行時に、class_evalに渡された文字列をパーズして、そ
のときに定数の探索範囲を決定するからです。その結果、13行目の周辺が、定
数の探索範囲となります。

<<click>>

Therefore, 'p method' outputs the string "K's CONST".

<<click>>

このような実行時にかわる範囲のことをdynamic scopeといいます。

<<click>>

= Constant Lookup is complex (part 2)

最後にそれぞれを並べて見てみましょう。

class_evalに渡す引数が違うだけで、定数の探索範囲はこのように違ってきます。

<<click>>

= Manage somehow

このように複雑な定数探索の問題を修正するのは、簡単ではありませんでした。

2回のやり直しがあり、3回目でようやく満足な結果を得ることが出来ました。
ソースコードの修正は3000行以上になりました。

<<click>>

この修正が完了したとき、MacRubyのメイン開発者であるLaurentは、チャット
で私にこう書きました。

<<click>>

21 Apr 2011 15:24
Laurent S.
it's official, kouji is the hero of the day/week/month/...? his patch seems to fix remaining lexical const lookup bugs :)

私はとてもうれしかったです。

このような複雑な問題を含め、いくつか修正しました。

<<click>>

= A very complex bug

しかし、喜んでいたのもつかの間で、私は定数探索に関するとても難しいエラー
を見つけました。

I found a behavior that is complex to implement.

<<click>>

This error can be reproduced by this code.

Let me explain this code sequentially from the top.

1行目で、module Aを定義します。
In line number one, we define module A.

2行目で、module Aに定数Bを定義します。
In line number two, we define constant B under module A.

5行目で、Aをレシーバに指定してclass_evalを実行します。
In line number five, we specify module A as receiver, and perform
class_eval with block.

6行目で、class_evalのブロックの中であるためレシーバはクラスAです。
そのため、クラスメソッドfを定義します。
In line number six, we are inside
class_eval block, so current receiver is module A.
Therefore, we define class method f of module A. 

7行目で、定数Bを標準出力に出力します。
In line number seven, we output Constant B to standard output.

11行目で、Aのfを呼び出します。そして、定数Bを出力するために探索します。
In line number eleven, we perform method f of module A. Then we're
looking up constant B to output.

<<click>>

このとき、最初にこの枠の範囲から定数Bを探索します。そして、見つからない
ため、Object、つまりトップレベルから定数Bを探索します。

<<click>>

ここで注意が必要です。class_evalのレシーバは、定数の探索範囲に含みませ
ん。これはRubyの言語仕様です。

<<click>>

両方とも見つからないため、定数Bの探索に失敗すると思ったの
ですが、

<<click>>

= A very complex bug (part 2)

なんと、Ruby 1.9 ではAからも探索していまい、定数Bを見つけてしまったのです。

<<click>>

でも、Ruby 1.8.7 は私の想像通り、定数Bの探索に失敗します。当然、
MacRuby もこのように動作します。

困った私は matz に相談しました。

<<click>>

その結果、これは Ruby 1.9 のバグだということになりました。
そして、あったいう間に修正されました。

<<click>>

= Demo

さぁ、それではみなさんに実際の成果をお見せするときがきました。

MacRuby で Rails を動作させます。
Rails works on MacRuby.

ここでは、Rails のバージョンは少し古いのですが 3.0.7 です。
At this time, I use Rails version 3.0.7 that is bit old.

(デモを開始)

<<click>>

= #1390 rb_vm_prepare_block

実は、Welcome Pageにある"About your application’s environment"リンクをクリックするとabortします。

Actually, MacRuby aborts if you click "About your application’s environment" link in Welcome page.

Rails を動かすのは定数探索よりも難しい問題ですね。
Hmm, working Rails on MacRuby is more difficult than to implement
lexical constant lookup, isn't it?

<<click>>

= MacRuby trip by the train continues...

MacRuby による電車の旅はまだまだ続きます。
ぜひ、みなさんも一緒に旅をしましょう。

<<click>>

This is MacRuby project URL.

<<click>>

This is MacRuby official twitter account.

<<click>>

MacRuby is on GitHub.

<<click>>

This is MacRuby Mailing List address.

<<click>>

= Conclusion

<<click>>

MacRuby
A unique blend of Ruby 1.9 and Objective-C.
The goal is to be 100% compatible with Ruby 1.9.

<<click>>

MacRuby on Rails
We became to show the Welcome Page.
But we have many things to complete.

<<click>>

= Q & A

それでは、何か質問はありますか？
質問される方は、できれば、ゆっくりとシンプルなものをお願いします。

<<click>>

= Acknowledgement

最後に、

このプレゼンテーションの機会を与えてくださった RubyConf の運営者の方に
感謝いたします。

<<click>>

私の少ない英語力を補ってくれた同僚の Tor に感謝いたします。

<<click>>

そして、私のつたない英語でのプレゼンテーションにつきあってくださった会
場のみなさまに感謝いたします。

<<click>>

ありがとうござました。

<<click>>

################################################################################
Local Variables:
mode: rd
End:
