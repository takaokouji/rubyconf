title: "RubyConf 2011 MacRuby on Rails 発表原稿"
author: "高尾宏治"
date: "2011/09/28"

= はじめに
Introduction

This is the manuscript for my presentation "MacRuby on Rails" for RubyConf2011.

On the day of the presentation,
I will generally speak as is written in this manuscript.

= MacRuby on Rails

(司会者がいない場合)
Now, I am about to start my presentation.

(司会者がいる場合)
Thank you for your kind introduction.

---

I would like welcome all of you.
It is a great honor for me to be here.

<<click>>

= Kouji Takao

Please let me introduce myself first. And let me introduce my company.

My name is Kouji Takao.
Both Kouji and Takao are commonly used as first names in Japan.
In my case, Kouji is my first name. And Takao is my last name.
Please call me Kouji.

<<click>>

= Work

I am a Research Engineer at Network Applied Communication Laboratory Ltd.
In Japan, my company is famous in connection with the Ruby programming language.

As for me, my work includes anything related to system integration.
For example,
system design, programming, planning and meeting with the customers.

And I work as the leader of small team.

<<click>>

= Spare Time

I develop open source software during my spare time.

I'm a MacRuby and cRuby committer.
In MacRuby, I am in charge of some of the core parts.
In cRuby, I am in charge of the Readline module.

<<click>>

= Contact Information

You can contact me on e-mail, twitter or facebook.

<<click>>

= My Company

As I said previously, my company's name is Network Applied Communication
Laboratory Ltd. 

<<click>>

My company is also known as NaCl.

<<click>>

As you probably know, NaCl means salt(ソォルト).
Salt(ソォルト) is necessary for all creatures to live.
This is why we named the company NaCl.

<<click>>

= My Company (part 2)

You can check out NaCl's homepage at www.netlab.jp.

<<click>>

NaCl is located in Shimane Prefecture in Japan.

<<click>>

The company was founded in 2001(two thousand and one).

<<click>>

So, 2011(two thousand and eleven) is the 10th(tenth) anniversary of the company.
As a matter of fact, it's also my own 10th(tenth) anniversary as an employee!
I'm very happy about that!!

<<click>>

57 people work at my company.

Wow, that's a lot of Rubyists!?
Just joking :)

<<click>>

Actually, about half of my co-workers work using Ruby.
However, 6 people are cRuby committers.

<<click>>

The company works with System Integration, Training and so on.

<<click>>

= The NaCl Way (part 1)

Please let me introduce The NaCl Way as I see it.

<<click>>

This is our president. His name is Hiroshi Inoue.

<<click>>

= The NaCl Way (part 2)

In a speech at my co-worker's wedding party, he said to my co-worker.

<<click>>

First, I want You to be happy.

<<click>>

Next, I want you to make Your Family happy.

<<click>>

Finally, if you have more happiness left, then please share it with Our Company :)

<<click>>

= The NaCl Way (part 3)

So I think the priorities of my company is as follows...

<<click>>

First, The Employee's well-being

<<click>>

Next, the well-being of the Employee's Family

<<click>>

And finally: The company itself

<<click>>

= The NaCl Way (part 3)

This is why I love my company!!

<<click>>

= MacRuby on Rails

Now, let's continue on to the main topic of today.

<<click>>

MacRuby on Rails

<<click>>

= MacRuby on Rails(part 2)

In my presentation,
I will explain how I modified MacRuby to make it a suitable foundation for running Rails.
I would also like to explain some of the technical intricacies that I discovered along the way.

<<click>>

<<click>>

= MacRuby

First, I would like to briefly explain about MacRuby.

<<click>>

= MacRuby (part 2)

MacRuby is a unique blend of Ruby 1.9 and Objective-C.

<<click>>

The goal of the MacRuby project is to be 100% compatible syntactically
and behaviorally with Ruby 1.9.

<<click>>

= Ruby 1.9

This is Ruby 1.9.

This system diagram shows the main building blocks of Ruby 1.9.
The top side shows the blocks facing the user,
and the bottom side shows the blocks facing the hardware.

<<click>>

At the top we have the applications made by the Ruby user.

<<click>>

Below that we have Ruby 1.9.
These are Ruby's main building blocks.

<<click>>

We have Ruby VM(ブィーエム), 
Ruby's Virtual Machine, 
which was previously called YARV(ヤーブィ).

<<click>>

We have the built-in garbage collection, which uses mark and sweep.

<<click>>

Then we have the Built-in Libraries, 
which includes the String class and the Array class and so on.

<<click>>

And then we have the Standard Library, 
which includes Readline, OpenSSL and other useful libraries.

<<click>>

Below Ruby, we have the system libraries.

<<click>>

And below the libraries, we have the Operating System.
Ruby 1.9 operates on a number of different platforms, 
among others Linux, Windows, Mac OS X and so on.

<<click>>

So, this is the structure of Ruby 1.9.

<<click>>

= MacRuby (part 3)

So let's try to compare this with the system diagram as it looks for MacRuby.
We'll look at each element in turn.

<<click>>

The application stays as it is.

<<click>>

Naturally, Ruby 1.9 becomes MacRuby.

<<click>>

Ruby VM(ヴィーエム) is replaced by LLVM(エルエルヴィーエム).

<<click>>

The built-in Garbage Collection is replaced by a mechanism provided by Mac OS X.
This Mac OS X feature is called AutoZone.
AutoZone is a Generational and Threaded Garbage Collection mechanism.

<<click>>

Part of the Built-in Library is replaced by a feature called Foundation
which is provided by Mac OS X.
Object, Array, String, Hash and others are replaced this way.
The result is that these classes get not only the functionality provided by Ruby,
but also the functionality provided by Foundation.

<<click>>

For instance, 
a Foundation method called "transform" is added to the Ruby String class.
This method can convert the alphabet version of my name "kouji"
into the corresponding japanese hiragana characters.

<<click>>

The Standard Libraries are more or less similar to Ruby 1.9.

<<click>>

The system libraries are also unchanged.

<<click>>

And the OS is of course Mac OS X.
Actually, MacRuby only runs on Mac OS X :P

<<click>>

= MacRuby (part 4)

So, if we look at the whole...
well, then it looks like this.

<<click>>

= Cocoa

On Mac OS X,
we have some libraries called Cocoa which are written in Objective-C.

The Cocoa includes more or less all the features of Mac OS X,
for instance a GUI toolkit, multimedia processing, text-to-speech and so on.

The majority of Mac OS X applications are developed using Cocoa.

<<click>>

= MacRuby x Cocoa

It is easy to use Cocoa in MacRuby.
Actually, we could say that MacRuby exists in order to allow us to use Cocoa.

<<click>>

= MacRuby x Cocoa
TODO: スライド側は大文字のXだけどこっちは小文字ですか。「かけさん」だったら小文字がいいかなと思います。--Tor

Well then, let's look at an example of how we can use Cocoa from MacRuby.

<<click>>

This is a sample program that plays a sound.

<<click>>

The purpose of the "framework" method is to load system libraries such as Cocoa.

<<click>>

This is the part where we are actually using Cocoa's functionality.
We specify a filename and we generate an instance of a sound file.
And then we call the "play" method to play back the sound.

<<click>>

So, now I am done with my introductory explanation of MacRuby.

<<click>>

= MacRuby on Rails

So, let's continue with the main topic, MacRuby *on Rails*.

So, I am going to talk about making Ruby on Rails works on MacRuby.

<<click>>

= Current Status

Let's see what we can currently do with MacRuby on Rails

<<click>>

Creating a new Rails project.

<<click>>

Generating a scaffold.

<<click>>

Starting up the server.

<<click>>

And ... showing the welcome page.

So, it is currently possible to run a Rails application on MacRuby
without modifying Rails.

However, it wasn't always like this.
Let's travel back in time!

<<click>>

= 7 months ago...

7(seven) months ago...

<<click>>

March 2011(two thousand and eleven) in Japan.

<<click>>

I thought, "Does Rails work on MacRuby?".

<<click>>

I tried to install Rails on MacRuby. And it worked.

<<click>>

= Perhaps...

So, I thought, "OK, it installed, but surely the Rails
generators won't work..."

<<click>>

I tried to create a Rails project.
And it actually worked!?

<<click>>

= Are you kidding me?

Not believing my own eyes, I tried to generate a scaffold...

<<click>>

Then it failed.

<<click>>

And starting up the server failed too.

After all Rails didn't work on MacRuby.

<<click>>

= My approach

So what did I do? My approach was to follow the five-step process
shown here iteratively.

<<click>>

First, I run Rails.

<<click>>

As the next step I see where it fails.
For instance, segmentation faults, aborted
programs and so on.

<<click>>

The third step is to research the cause of the failure.

<<click>>

The fourth step is to code a patch that fixes the problem.

<<click>>

And finally, I run RubySpec to verify my patch, 

<<click>>

and repeat from the top if necessary.

<<click>>

In order to do this, I needed to know about cRuby, Objective-C, C++
and LLVM.

When you just work with cRuby then you only need to know about cRuby.

But, when you want to code patches for MacRuby then you also need to
know about Objective-C, C++ and LLVM.

So, I think that to code patches for MacRuby is more difficult than
to do so for cRuby.

<<click>>

= The Fixed Issues
SLIDE_TODO: "The Fixed Issues"を"A couple of examples of what I have fixed so far"にしたらどうですか？

Now, I would like to discuss a couple the issues that I fixed in MacRuby.

<<click>>

= #860 catch/throw

Let's have a look at the first case, which is ...

Trac Issue number 860(eight six zero),
an issue with catch and throw and exception handling in MacRuby.

<<click>>

This error can be reproduced by this code.

<<click>>

If you run this code, then the following error will occur.

Let me try to explain the reason.

<<click>>

= Exception

First, we need to know a little bit about how exception handling is done in MacRuby.
TODO:これ以降のスライドの題名は「Exception」ですが、「Exception Handling」にしたほうがいいと思います。

<<click>>

Have a look at this code.
In this program we raise and rescue twice.

Let's look at what happens when we run this program on MacRuby.

<<click>>

On line two, we raise exception A.

<<click>>

On MacRuby, raised exceptions are stored in a stack.
We call this stack the Exception Stack.

<<click>>

<<click>>

On line 3, we rescue exception A and continue execution.

<<click>>

On line 5, inside the rescue block, we raise exception B.

<<click>>

So, exception B is pushed onto the stack.

<<click>>

On line 6, we rescue exception B and continue executing the code.

<<click>>

On line 7, we reach the end of the inner rescue block,
so MacRuby pops one exception of the stack.

<<click>>

And on line 8,
we reach the end of the outer rescue block,
and again we pop an exception from the Exception stack.

So, now we're done handling all the exceptions raised by this program.
And the Exception stack is empty.

This is the way that MacRuby stores and processes exceptions.

<<click>>

= Exception and catch / throw

次に、例外処理と catch / throw を組み合わせたときの実現方法を説明します
So let's look at how exception handling is carried out when in combination with catch and throw.

<<click>>

このコードを見てください。
Have a look at this code.

このプログラムでは例外が発生したあとで、throwによってcatchまでジャンプ
しています。
In this program,
we define a catch block labeled "foo".
Inside the catch block we have a begin-rescue where we raise an exception.
And in the rescue block we use "throw" to jump out ouf the begin-rescue.
TODO:これであったますか？trowによってどこに飛ぶかはわからないのでそれを避けました。

先ほどと同様に、Exception Stackの内容に着目しながら、このプログラムを
MacRubyで実行したときの様子を見てみましょう。
Let's step through the execution again to see what happens in the MacRuby Exception stack, just like we did in the last example.

<<click>>

1行目で、:fooを指定してcatchを実行しています。
On line 1, we define a labeled block using 'catch'.

catchに指定したブロックの中で:fooを指定してthrowを実行すると、
catchのブロックを抜け出すことが出来ます。
After that, if we call 'throw' with symbol foo as an argument,
then we jump out of the block.

<<click>>

3行目で、例外が発生します。それを例外スタックに追加します。
On line 3,
we raise exception A.
So, it is pushed onto the stack.

<<click>>

4行目で、その例外をrescueして、処理を続けています。
On line 4, we rescue exception A and continue execution.

<<click>>

5行目で、:fooを指定してthrowを呼び出しています。
On line 5, we call 'throw' with symbol foo as the argument.

<<click>>

その結果、catchのブロックを抜け出します。
So, we jump out of the labeled block.

<<click>>

このとき、例外スタックから例外を1つ取り除きます。
Then, MacRuby pops exception A from the stack.

このように、MacRubyでは、throwでも例外スタックから例外を取り除きます。
So this is how throw takes out exceptions from the stack in MacRuby.
<<click>>

= throw

当時のMacRubyのthrowの実装はこのようになっていました。
Before I patched it, MacRuby's 'throw' was implemented as you can see here.

throwの実装は ソースコードvm.cppの4321行付近にあります。
This code is from vm.cpp.
TODO:行数まで言わなくていい気がします。

throwはC++で実装されています。
'throw' is implemented in C++.

<<click>>

current_exception()関数は、例外スタックの一番上に積まれている例外を返します。
The current_exception() function returns the topmost exception from the stack.

<<click>>

pop_current_exception()関数は、例外スタックから例外を一つ取り除きます。
And, the pop_current_exception() function pops one exception off the stack.

<<click>>

= #860 catch/throw

それでは、もう一度、今回の問題の再現コードを見てみましょう。
Now, have a look at the code that reproduces the error once again.

先ほどと同様に、Exception Stackの内容に着目しながら、このプログラムを
MacRubyで実行したときの様子を見てみましょう。
Let's look at what happens when we run this program on MacRuby while
attention to the Exception Stack.
TODO: 毎回と同じなので、この文書はこれで言わなくていいと思います。
SLIDE_TODO: スライド１１９は必要ないですかね？

<<click>>

2行目で、例外が発生します。
それを例外スタックに追加します。
On line 2,
we raise exception A.
So, exception A is pushed onto the stack.

<<click>>

3行目で、その例外をrescueして、処理を続けています。
On line 3, we rescue exception A and continue executing.

<<click>>

4行目で、catch と throw を実行します。
On line 4, we call 'catch' and 'throw'.

<<click>>

throw の実行時に、例外スタックから例外を1つ取り除きます。
Then, MacRuby pops one exception of the stack.

そして、例外スタックは空の状態になります。
And the stack is empty.

<<click>>

5行目で、rescue節を含むendに到達したので例外スタックから例外を1つ取り除こうとします。
On line 5,
we reach the end of the outer rescue block,
and again we pop an exception off the stack.

しかし、例外スタックは空になっています。
However, the stack is empty.

<<click>>

その結果、abort してしまうのです。
Therefore, MacRuby aborts.

<<click>>

=TODO

 「How to fix」までの説明はもうスライドからなくなっているけど、どうしますか？この説明がなければ、Railsとのつながりがちょっと薄くなるきがします。

ここでこのような内容のスライドあったらいいかもしれないです。

1. MacRuby previously assumed the following way of writing exception handling.
想定された構造のスライド
2. But Rails breaks this assumption by using catch-foo inside a rescue clause
エラーを発生させるコード
3. So running Rails on MacRuby has exposed a weakness in MacRuby's exception handling.

これだったら、次の「じゃどう直せばいい」という話へにつながりも大丈夫だと思います。そして、以下のHow to fixまでの文を消してしまってもいいとおもいます。

=END

みなさんもお気付きのように、この問題の原因は 4 行目の throw で例外を取り除いてしまったことです。
As you can probably see, 
that the cause of the error has poped one exception of the stack
on line 4.

The issue does not occur, as long as you don't break this assumption.

With this exception handling structure, if we reach end, then it means that throw was NOT executed. On the other hand if throw is executed, then we break out of the begin rescue end block before we reach end.

In other words, this structure ensures that you never pop more than one exception from the stack.

しかし、Railsではこの前提が崩れてしまった。
However, this assumption does not hold true in Rails.

そのため動かなかった。
So, this caused an error when running Rails on MacRuby.

<<click>>

= How to fix

TOR_TODO:

この問題の修正方法を説明します。
Let me explain how to fix the error.

まずは、修正後のプログラムの動作を見てみましょう。
First,
let's look at what happens when we run this program on MacRuby after we fixed the error.

<<click>>

3行目までは、先ほどと同じように動作します。
Up until line 3, things work as they always did.

<<click>>

4行目で、まず、catchを実行したときに、例外スタックの一番上に積まれている例外を記録しておきます。ここでは例外"A"を記録します。
However, now things work a bit different from line 4.
Now, when we call 'catch',
then we store a record of what is at the top of the exception stack.
In this case, exception A.

<<click>>

次に、throwを実行したときに、catchで記録した例外と、例外スタックの一番上に積まれている例外を比較します。
Next, when we call 'throw', we compare the exception that we stored, with the exception at the top of the exception stack.
TODO:若干省略しましたが、どうですか？

それらが等しければ何もしません。
If these two exceptions are the same, then MacRuby doesn't do anything.

それらが違っていたら例外スタックから例外を取り除きます。
If they are different, then MacRuby pops one exception off the stack.

ここでは、どちらも例外"A"なので何もしません。
Now, in this case, they are the same, so MacRuby doesn't do anything.

<<click>>

5行目で、例外スタックから例外を1つ取り除きます。
On line 5, MacRuby pops an exception from the stack.

そして、例外スタックは空の状態になります。
And then the stack is empty.

So this is how the new implementation of throw works.

<<click>>

= How to fix (part 2)

これをthrowに実装したのがこのコードです。
This is the fixed implementation of throw.

SLIDE_TODO:
「I changed the implementation so that MacRuby only pop Exceptions if it needs to.(60723bf)」を「In the new implementation, MacRuby
only pops exceptions when necessary (60723bf)」にしたほうが自然かなと思います。そして、喋りに

So, I changed the implementation so that MacRuby only pops exceptions when needed.


<<click>>

この部分で、catchで記録した例外と例外スタックの一番上に積まれている例外を比較しています。
So, the code in the green frame is where we compare the stored exception with the exception at the top of the stack.

<<click>>

この部分は、例外スタックの一番上に積まれている例外を取り除いています。
And in this part, MacRuby pops one exception off the stack.

So in short, we keep popping exceptions off the stack until the while condition turns false, or in other words until we reach the recorded exception.
TODO:まとめる文書を追加しましたので、ご確認ください。

<<click>>

= #860 Fixed

最後に、もう少し複雑なコードで修正後のMacRubyの動作を確認してみましょう。
Finally,
let's look at what happens when we run a more complex program on MacRuby with the fixed implementation of throw.

<<click>>

2行目で、例外が発生します。それを例外スタックに追加します。
On line 2,
we raise exception A.
TODO:せっかくなので、2行目に矢印があるスライドを。。。

So, exception A is pushed onto the stack.

3行目で、その例外をrescueして、処理を続けています。
On line 3, we rescue exception A and continue executing the code.

4行目で、catchを実行します。このとき、例外"A"を記録します。
On line 4,
we call 'catch' and store exception A.

<<click>>

6行目で、例外が発生します。それを例外スタックに追加します。
On line 6,
we raise exception B and push it onto the stack.

<<click>>

7行目で、その例外をrescueして、処理を続けています。
On line 7, we rescue exception B and continue execution.

8行目で、throwを実行します。
On line 8, we call 'throw'.

このとき、catchで記録した例外"A"と例外スタックの一番上の例外"B"を比較します。
Then we compare the recorded exception A with exception B of the stack.

<<click>>

それぞれが異なるため、例外"B"を例外スタックから取り除きます。
These are different, so MacRuby pops exception B of the stack.

もう一度、catchで記録した例外"A"と例外スタックの一番上の例外"A"を比較します。
Then, we compare the recorded exception A with the new top of the stack, which is now exception A.

それぞれが等しいため何もしません。
These are same, so MacRuby doesn't do anything.

<<click>>

そして、catchのブロックを抜けます。
Then, we jump out the labeled catch block.
TODO:確認おねがいします。

<<click>>

11行目で、例外スタックから例外を1つ取り除きます。
On line 11, MacRuby pops one exception of the stack, and the program finishes without aborting.

私は、このようにして、この問題を修正しました。
So this is how I fixed the problem.

<<click>>

= #1192 Constant lookup

Next, let's look at another example of how I fixed MacRuby.
This time we'll look at Trac Issue number 1192 (one one nine two),
which is related to Constant Lookup in MacRuby.

The issue was that MacRuby failed 
to correctly look up constants in a number of situations
when you used module_eval and class_eval.

<<click>>

This error can be reproduced by this code.

<<click>>

If you run this code, then the following error will occur.

<<click>>

Please look at the line with Object .(dot) class_eval.

In cRuby, when we look for the constant B, 
we start looking within the green box.
So, we are able to find constant B.

<<click>>

However, in the MacRuby, at that time,
we only looked within class_eval's receiver object.
And since constant B isn't defined there,
the constant lookup would fail in MacRuby.

<<click>>

= Constant Lookup

To really understand this issue,
you must have a detailed understanding of how constant lookup works in Ruby.
I think that constant lookup is one of the parts of Ruby's language specification that are quite hard to understand.

And in most cases,
you can get along quite fine without knowing anything about this area.

<<click>>

Let's have a look at this code.
We'll look at it from the top and down.

<<click>>

On line 1, we begin the definition of module A.

<<click>>

And on line 2, we begin the definition of module B.

<<click>>

On line 3, we define a constant called CONST in module B.

<<click>>

On line 4,
we re-open the top-level module A.
in other words,
the module A that we defined in line 1.

<<click>>

And finally,
on line 5,
we print the contents of the constant CONST to the standard output.

<<click>>

In this example,
cRuby would look for the constant CONST within the green frame.

We call the scope represented by the green frame for "Lexical Scope"

And, cRuby would find the CONST that is defined in module B.

<<click>>

And here, for the sake of this presentation,
I am going to refer to the lookup of constants within Lexical Scope as "Lexical Constant Lookup".

<<click>>

= But...

At the time, MacRuby had not implemented Lexical Constant Lookup.

<<click>>

In this code on line 5,
MacRuby only looks for the constant CONST within module A.

<<click>>

Therefore, CONST cannot be found.

<<click>>

= Constant Lookup is complex
SLIDE_TODO: どんな実装、またはどんな仕様の定数検索の話かをスライドにはっきりかくといいと思います。

Next,
we have an example with class_eval.

Constant lookup becomes even more complex when we use class_eval.

<<click>>

The behavior changes
depending on whether we pass a block or a string as the argument to class_eval.

In the code example on the left hand we pass a block.

And in the right hand example we pass a string.

Except for the different arguments, the two examples are identical.

<<click>>

= class_eval(&Block)

TOR_TODO:

First, I'll explain about calling class_eval with a block.
Let me explain this code sequentially from the top.

<<click>>

On line 1, we define module A.

<<click>>

On line 2, we define the constant CONST

<<click>>

On line 3, we define method f.

<<click>>

On line 4, we pass a block to class_eval.

<<click>>

On line 5, we print the content of CONST to the standard output.

<<click>>

On line 6, we close the class_eval block.

So, when we call method f, then line four to six will get executed.

<<click>>

On line 10, we define class K.

<<click>>

On line 11, we define another constant called CONST,
but this time inside class K.

<<click>>

As you can see on line 12, we extend class K with module A.

<<click>>

On line 13, we call module A's f method.
As a result, the code in line 4 to 6 is called.

このときの定数CONSTを最初に探索する範囲がわかりますか？
So, can you tell what the constant lookup scope is in this case?
TODO:「最初に」は重要ですか？それとも、この修正でいいですか？

<<click>>

これは簡単ですね。
In this case it is easy to tell.

この枠の範囲から最初に定数CONSTを探索します。
We look for the constant CONST within the green frame.

<<click>>

So in this case the 'p' outputs the string "A's CONST"ｄ

<<click>>

= class_eval(String)

次に、文字列を渡す場合についてです。
Next, let's look at performing class_eval with a string argument.

先ほどのものとの違いは4〜6行目だけです。
The code example only differs on line 4(four) to 6(six).

4行目で、class_evalを文字列を渡して呼び出します。
On line 4, we pass a string to class_eval in the form of a HERE document.

5行目で、定数CONSTを標準出力に出力します。
On line 5, we print the content of CONST.

6行目で、ヒアドキュメントの終端です。
On line 6, we close the HERE document.

そして、13行目で、module Aのメソッドfを呼び出します。
Just as before, we call module A's f method on line 13.

このときの定数CONSTを最初に探索する範囲がわかりますか？
So, can you tell what the constant lookup scope is in this case?
TODO:「最初に」は重要ですかね

<<click>>

実はこの枠の範囲です。
Actually, on MacRuby, we would look for CONST within this green frame.
TODO:これはMacRubyの挙動であってますか？


この理由を説明します。
Let me explain the reason.

メソッドfの実行時に、class_evalに渡された文字列をパーズ・解釈します。
When we call module A's f method,
we parse and evaluate the string that is passed to class_eval.
TODO：この辺(この文＋３）は相談させてください。ちょっと曖昧さがあるので、正しい翻訳はむずかしいです。

そのときに定数の探索範囲を決定します。
And, the scope in which we look for CONST is determined when to be the scope in which the method f is run.

その結果、13行目の周辺が、定数の探索範囲となります。
Therefore, the lookup scope becomes determine around line 13.

このような実行時にかわる範囲のことをdynamic scopeといいます。
We call the scope represented by the green frame for "Dynamic Scope".



<<click>>

So in this case the 'p' outputs the string "A's CONST"ｄ

<<click>>

= Constant Lookup is complex (part 2)

TOR_TODO:

最後にそれぞれを並べてみましょう。
So lets look at the two cases together.

class_evalに渡す引数が違うだけで、定数の探索範囲はこのように違ってきます。
We can see that the scope of the constant lookup differs greatly depending on the kind of argument passed to class_eval.

<<click>>

= Manage somehow
SLIDE_TODO:「Manage somehow」＞「I somehow managed to fix this」　ここの日本語を聞かせてください。あまりいい題名を思いつかないです。


このように複雑な定数探索の問題を修正するのは、簡単ではありませんでした。
It was not easy to fix this error.

2回のやり直しがありました。そして、3回目でようやく修正できました。
I had to start over twice.
And I was finally able to find a satisfactory solution in the third attempt.
SLIDE_TODO:　Three attempts to get it right.

<<click>>

ソースコードの修正は3000行以上になりました。
I edited more than 3000 lines of code.
SLIDE_TODO: More than 3000 lines of code changed.

この修正が完了したとき、MacRubyのメイン開発者であるLaurentは、チャット
で私にこう書きました。
When I finally managed to fix this error,
Laurent who is a main developer of MacRuby,
said to me that,

<<click>>

21 Apr 2011 15:24
Laurent S.
it's official, kouji is the hero of the day/week/month/...? his patch seems to fix remaining lexical const lookup bugs :)

私はとてもうれしかったです。
I had been very happy!!

<<click>>

= A very complex bug

TOR_TODO:

しかし、喜んでいたのもつかの間で、私は定数探索に関するとても難しいエラー
を見つけました。
However, I found a behavior that is complex to implement.

<<click>>

This error can be reproduced by this code.

Let me explain this code sequentially from the top.

<<click>>

On line one, we define module A.

<<click>>

On line two, we define constant B under module A.

<<click>>

On line five, we specify module A as receiver, and perform
class_eval with block.

<<click>>

On line six, we are inside
class_eval block, so current receiver is module A.
Therefore, we define class method f of module A. 

<<click>>

On line seven, we output Constant B to standard output.

<<click>>

On line eleven, we perform method f of module A.
Then we're looking up constant B to output.

<<click>>

このとき、最初にこの枠の範囲から定数Bを探索します。
Now, we are going to look for constant B within the green frame.

そして、見つからないため、Object、つまりトップレベルから定数Bを探索します。
And we fail.
Then, we are going to look for constant B from Object.
It also means we are going to look for constant B that is defined at top level.

<<click>>

ここで注意が必要です。
Please be careful.

class_evalのレシーバは、定数の探索範囲に含みません。これはRubyの言語仕様です。
'class_eval' doesn't add receiver(A) to constant lookup scope.
This is a Ruby's speficication.

そして、両方とも見つからないため、定数Bの探索に失敗すると思ったのですが、
So, I thought that we failed to look for constant B,

<<click>>

= A very complex bug (part 2)

TOR_TODO:

なんと、cRuby 1.9 ではAからも探索してしまい、定数Bを見つけてしまったのです。
Wow, cRuby 1.9 are looking for constant B from module A. Then it succeeded.

<<click>>

でも、Ruby 1.8.7 は私の想像通り、定数Bの探索に失敗します。
But, Ruby 1.8.7 failed.

当然、MacRuby もこのように動作します。
MacRuby is same.

困った私は matz に相談しました。
So, I asked matz advice for about this behavior.

<<click>>

その結果、これは Ruby 1.9 のバグだということになりました。
He said this is a cRuby 1.9 bug.

そして、あったいう間に 1.8.7 と同じ動作に修正されました。
Then, cRuby 1.9 behavior fixed as Ruby 1.8.7 soon.

<<click>>

= Demo

TOR_TODO:

さぁ、それではみなさんに実際の成果をお見せするときがきました。
OK, then let's show result to all of you.

MacRuby で Rails を動作させます。
Making Rails works on MacRuby.

ここでは、Rails のバージョンは少し古いのですが 3.0.7 です。
At this time, we use Rails version 3.0.7 that is bit old.

(デモを開始)

<<click>>

= #1390 rb_vm_prepare_block

Actually,
MacRuby aborts
if you click "About your application’s environment" link in Welcome page.

Hmm, working Rails on MacRuby is more difficult
than to implement lexical constant lookup, isn't it?

<<click>>

= The MacRuby train trip continues ...

The MacRuby train trip continues ...
Everyone, please get on board.

<<click>>

This is the URL for the MacRuby project's homepage.

<<click>>

This is MacRuby's official twitter account.

<<click>>

MacRuby is on GitHub.

<<click>>

This is the MacRuby Mailing List's address.

<<click>>

= Conclusion

TOR_TODO:

私のプレゼンテーションのまとめです。
Let me explain this presentation conclusion.

<<click>>

MacRuby is a unique blend of Ruby 1.9 and Objective-C.
The goal is to be 100% compatible with Ruby 1.9.

<<click>>

MacRuby on Rails
We're now able to show the default Rails welcome page.
But there is still a lot to do.

<<click>>

= Q & A

And now, I would like to answer any questions you have.

If you have a question, please ask me, but if possible please speak slowly.

<<click>>

= Acknowledgement

TOR_TODO:

Last of all,

I would like to express my gratitude toward the RubyConf hosts and organizers
for giving me the opportunity to give this presentation.

<<click>>

私の少ない英語力を補ってくれた同僚の Tor に感謝いたします。
And, I would like to thank my co-worker Tor Yamamoto-Sorensen (@shakaijin) who helped me with this presentation.
TODO:

<<click>>

And finally,
I would like to thank my everyone here,
for patiently listening to this presentation,
despite my clumsy English.

<<click>>

= Thank you

Thank you very much.

################################################################################
Local Variables:
mode: rd
End:
